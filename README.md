* Как сравниваются элементы коллекций?
Для сравнения элементов коллекций используется метод equals().
Если необходимо сравнивать объекты не по reference, а по value объекта, то тогда необходимо переопределить equals() и hashcode().Если наш пользовательский класс переопределяет equals(), то он должен и переопределить hashcode(). Если два объекта эквивалентны, то и хэш коды этих объектов тоже должны быть равны.

* Почему Map не относится к Collection?
.Map представляет собой абсолютно другую структуру данных – набор ключей и соответствующих значений, а коллекция это набор определенного типа значений. Map не не относится к  Collection, поскольку интерфейс Collection в значительной степени несовместим с интерфейсом Map.

* Что такое итератор и как он работает в коллекциях?
Итератор — это классический паттерн проектирования, который позволяет пройтись по элементам составных объектов, не зная их внутренней реализации. В java реализацией этого паттерна является интерфейс Iterator и его реализации в соответствующих коллекциях.
Итератор можно получить к любому типу данных, который реализует Iterable и пройти по всем элементам этого составного объекта при помощи методов  hasNext()  и next().

* Как можно перебрать все значения HashMap? Как перебрать все значения HashMap?
Оптимальным способом является получение всех значений с помощью метода
values() и перебором всех значений коллекции, которые мы получили в values().
Также можно перебрать все элементы при помощи entrySet()

* Что будет если объект который выступал в качестве ключа в структуре MAP поменяется?

Все зависит от реализации Map и реализации  equals() и hashCode() объекта, который используется в качестве ключа. Если мы используем HashMap, и значение ключа, который используется в hashCode изменилось, то может создаться такая ситуация, когда HashMap будет иметь два одинаковых ключа, что противоречит этой структуре данных.
Допустим в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется.
JavaDoc: большая осторожность должна быть проявлена, если изменяемые объекты используются в качестве ключей Map. Поведение Map не задается, если значение объекта изменяется таким образом, что влияет на сравнение равных, в то время как объект является ключом в Map.

* Разница между Iterable и Iterator.
Iterator это интерфейс, который позволяет пройтись по набору составных элементов,
a Iterable это интерфейс, который реализуется всеми коллекциями, которые отдают итератор.
Iterable имеет два метода: Iterator(), который отдает итератор и forEach(), который уже реализован по умолчанию, который позволяет использовать нам цикл for для всех объектов, которые реализуют Iterable интерфейс.

* Что будет если вызвать Iterator.next()?
Мы получим следующий элемент итератора. Рекомендуется вызывать метод hasNext() перед использованием next(), чтобы убедиться, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException.

* Что будет если добавить еще один элемент в коллекцию во время работы итератора?
Зависит от структуры данных, в некоторых будет нарушена логика работы итератора.
Во время итерации, поведение не указано, если базовая коллекция модифицируется каким-либо другим способом, пока выполняется итерация.
Iterator.remove - единственный безопасный способ изменения коллекции 








